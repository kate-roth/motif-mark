#!/usr/bin/env python

## be sure to activate environment where pycairo is installed

import argparse
import re
import cairo


def get_args():
    parser = argparse.ArgumentParser(description="Visualize cassette exon splicing motifs. Outputs an SVG file.")
    parser.add_argument("-f", "--file", help="fasta file with gene sequence(s) to be visualized, exons must be capitalized and introns lowercase", required=True, type=str)
    parser.add_argument("-m", "--motifs", help="text file with motifs one per line, IUPAC compatible", required=True, type=str)
    return parser.parse_args()

# store args
args = get_args()
genes_fasta = args.file
motifs_file = args.motifs

# extract file prefix
spl_name = re.split("\.", genes_fasta)
prefix = spl_name[0]    # store prefix for naming output svg

# constants for figure
height_per_gene = 150
left_margin = 50
right_margin = 400      # make big enough to fit legend
feature_height = 35     # height of exon and motif rectangles
label_font = 14
alpha = .75

# rgb colors, will be converted to 0-1 values
colors256 = [
    (58, 52, 235),  # blue-purple
    (50, 168, 82),  # green
    (31, 237, 237), # light blue
    (237, 127, 31), # orange
    (255, 102, 229)   # fuscia
]

# IUPAC encodings
IUPAC = {
    "A":"A",
    "C":"C",
    "G":"G",
    "T":"T",
    "U":"T",  # change U to T
    "W":"[A,T]",
    "S":"[C,G]",
    "M":"[A,C]",
    "K":"[G,T]",
    "R":"[A,G]",
    "Y":"[C,T]",
    "B":"[C,G,T]",
    "D":"[A,G,T]",
    "H":"[A,C,T]",
    "V":"[A,C,G]",
    "N":"[A,C,G,T]",
    "Z":"[]",
}

## Functions ---------------------------------------------------------------------

## genes --
def parse_introns_exon(seq):
    '''input sequence with lowercase intron, uppercase exon, lowercase intron,
    returns length of intron1, the exon, and intron2'''
    i1 = 0  # intron
    e = 0   # exon
    i2 = 0   # intron
    total = 0
    for n in seq:
        if e == 0 and n.islower():
            i1+=1
        elif n.isupper():
            e+=1
        elif i1 != 0 and e != 0 and n.islower():
            i2+=1
    total = i1 + e + i2
    return (i1,e,i2, total)

def get_genes(fasta):
    '''parses a fasta file where the introns are lowercase and exons are uppercase,
    returns dictionary where keys are gene1,gene2,etc. and values are [header, sequence, (intron1 len, exon len, intron2 len)]'''
    with open(fasta, "r") as fa:
        genedict = {}       # {gene1: [header, sequence, (intron1 len, exon len, intron2 len)]}
        header = ""
        record = []
        n = 1
        keyname = ""
        for line in fa:
            line = line.strip()
            if record != []:
                if line[0] != ">":                # if record has something in it and line is a sequence line
                    record.append(line)           # append sequence
                else:                             # if record has something and is a header line, then what is stored in record is a full record
                    header = record[0].strip(">")            # header first element in the record list
                    keyname = "gene" + str(n)
                    whole_seq = ""          # concat to get whole sequence
                    for s in record[1:]:
                        whole_seq += s

                    in_ex_lens = parse_introns_exon(whole_seq)    # get introns and exon lengths

                    genedict[keyname] = [header, whole_seq, in_ex_lens]    # add to dict

                    record = []             # clear record
                    record.append(line)     # add header for the new record
                    n+=1
            else:                    # append first header line
                record.append(line)
            
            # need to do these same steps for the last record
            header = record[0].strip(">")
            keyname = "gene" + str(n)
            whole_seq = ""
            for s in record[1:]:
                whole_seq += s
            in_ex_lens = parse_introns_exon(whole_seq)
            genedict[keyname] = [header, whole_seq, in_ex_lens]
    return genedict


## motifs --
def get_motif_patterns(txt_file):
    '''input text file where there is 1 IUPAC encoded motif per line,
    converts to uppercase, and returns a list of motif regex patterns'''
    motif_ls = []
    with open(txt_file, "r") as txt:
        n = 1
        for line in txt:
            pattern = ""
            line = line.strip()
            for l in line.upper():      # build regex pattern using IUPAC dict
                pattern += IUPAC[l]
            motif_ls.append((line.upper(), pattern))
            n+=1
    return(motif_ls)

def get_motif_positions(pattern, orig_motif, seq):
    '''input regex pattern generated by get_motif_patterns(), the original IUPAC motif, and sequence to scan,
    converts U's in sequence to T's,
    returns dtionary where keys are the original IUPAC motif and values are the start, end, and seq that matched'''
    motif_spans = []
    if "U" in seq.upper():  # check for U's in sequence
        seq = re.sub("U", "T", seq.upper())
    for x in re.finditer(pattern, seq):
        motif_spans.append((x.start(), x.end(), x.group()))
    return {orig_motif:motif_spans}     # {IUPAC motif:[(start, end, match),...()]}


# figure functions --
def generate_fig_dim(gene_dict):
    '''uses gene information to determine size of the figure,
    returns the width and height'''
    longest_len = 0
    for g in gene_dict.values():    # determine longest gene
        if len(g[1]) > longest_len:
            longest_len = len(g[1])
    fig_width = (longest_len + right_margin) // 100 * 100    # for legend and round to 100
    fig_height = len(gene_dict) * height_per_gene   # height depends on number of genes
    return fig_width, fig_height

def color_transf(col_ls):
    '''transforms rgb from 0-256 to 0-1,
    returns list of (r,g,b) tuples as floats'''
    new_col_ls = []
    for c in col_ls:
        new_c = []
        for d in c:
            new_c.append(d/256)
        new_col_ls.append((new_c[0],new_c[1],new_c[2]))
    return new_col_ls

def draw_genes_and_motifs(gene_dict, motif_ls, ctx, cols):
    '''input gene and motif info, context surface, and float colors,
    draws genes where lines are introns and black rectangle is the exon and labels gene with fasta header line
    returns dict where keys are gene headers and values are dictionaries of the motifs generated by get_motif_positions()'''
    gene_n = 1
    genes_and_motifs = {}   # for printing purposes
    for g in gene_dict.values():
        # set positions
        gene_ypos = (gene_n*height_per_gene)-(height_per_gene/2)
        label_pos = gene_ypos - (height_per_gene/4)

        # label gene
        ctx.set_source_rgb(0, 0, 0) 
        ctx.set_font_size(label_font)
        ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
        ctx.move_to(left_margin, (label_pos))
        ctx.show_text(g[0])
        ctx.stroke()

        # draw line (introns)
        ctx.set_line_width(1)
        ctx.move_to(left_margin, gene_ypos)
        ctx.line_to((left_margin+g[2][3]), gene_ypos)
        ctx.stroke()

        # draw exon
        ctx.set_line_width(feature_height)
        ctx.move_to((left_margin+g[2][0]), gene_ypos)
        ctx.line_to((left_margin+g[2][0]+g[2][1]), gene_ypos)
        ctx.stroke()

        gene_n+=1

        # draw motifs
        all_motifs = []     # list for compiling motif info
        for i in range(len(motif_ls)):
            mtfs = get_motif_positions(motif_ls[i][1], motif_ls[i][0], g[1].upper())    # {IUPAC motif:[(start, end, match),...()]}
            all_motifs.append(mtfs)
            for n in mtfs.values():
                for o in n:     # draw motifs, different motifs have different colors
                    ctx.set_source_rgba(cols[i][0], cols[i][1], cols[i][2], alpha)
                    ctx.set_line_width(feature_height)
                    ctx.move_to((left_margin+o[0]), gene_ypos)
                    ctx.line_to((left_margin+o[1]), gene_ypos)
                    ctx.stroke()
        
        # for printing purposes
        genes_and_motifs[g[0]] = all_motifs
    return(genes_and_motifs)


def draw_legend(motif_ls, cols, ctx):
    '''input motif patterns list, colors as floats (0-1), and the context surface,
    draw legend'''
    legend_xstart = width - 300     # choose offset smaller than right_margin
    legend_ystart = 75
    col_box_size = 20

    # write "Legend"
    ctx.set_source_rgb(0, 0, 0)
    ctx.set_font_size(col_box_size)
    ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
    ctx.move_to(legend_xstart, legend_ystart)
    ctx.show_text("Legend")
    ctx.stroke()

    for i in range(len(motif_ls)):
        legend_ypos = legend_ystart + (i*30) + 20
        
        # draw color box
        ctx.set_source_rgba(cols[i][0], cols[i][1], cols[i][2], alpha)
        ctx.set_line_width(col_box_size)
        ctx.move_to(legend_xstart, legend_ypos)
        ctx.line_to(legend_xstart+col_box_size, legend_ypos)
        ctx.stroke()

        # write orig motifs
        ctx.set_source_rgb(0, 0, 0) 
        ctx.set_font_size(col_box_size)
        ctx.move_to(legend_xstart+col_box_size+10, legend_ypos+5)
        ctx.show_text(motif_ls[i][0])
        ctx.stroke()


# Main ---------------------------------------------------------------------------

# parse input files
genes = get_genes(genes_fasta)      # {gene1:[header, sequence, (intron1 len, exon len, intron2 len)], gene2:...}
motif_pat = get_motif_patterns(motifs_file)    # [(original motif seq, regex pattern),...]

# create svg
width, height = generate_fig_dim(genes)
dec_colors = color_transf(colors256)

surface = cairo.SVGSurface((prefix+".svg"), width, height)
context = cairo.Context(surface)

motifs_by_gene = draw_genes_and_motifs(genes, motif_pat, context, dec_colors)
draw_legend(motif_pat, dec_colors, context)

surface.finish()

# print gene headers and motif matches
for k,v in motifs_by_gene.items():
    print("Gene:", k)
    for i in v:
        for k2,v2 in i.items():
            print("Motif:",k2)
            for i2 in v2:
                print(i2)

